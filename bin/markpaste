#!/usr/bin/env node

/**
 * markpaste
 *
 * 1. Reads HTML from the clipboard (via raw hex from osascript)
 * 2. Cleans and converts it to Markdown using MarkPaste
 * 3. Saves Markdown as Plain Text and Cleaned HTML as HTML back to clipboard
 * 4. Verifies the set content.
 */

import { execSync, spawnSync } from 'node:child_process';
import { writeFileSync, unlinkSync } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import os from 'node:os';

import { convert, cleanHTML, isProbablyMarkdown } from '../src/index.js';
import { marked } from 'marked';

/**
 * Formats a string for preview in the logs (truncated, escaped, and dimmed).
 */
function textToPreview(text, length = 100) {
  const dimmedStart = '\x1b[2m';
  const dimmedEnd = '\x1b[22m';
  const preview = text.substring(0, length).replace(/\n/g, '\\n');
  return `${dimmedStart}${preview}${dimmedEnd}...`;
}

/**
 * Reads the HTML flavor from the macOS clipboard.
 * Returns null if no HTML flavor is present.
 */
function readHtmlFromClipboard() {
  try {
    const script = 'try\n  the clipboard as «class HTML»\non error\n  return ""\nend try';
    const hexData = execSync(`osascript -e '${script}'`, { encoding: 'utf8' }).trim();
    const match = hexData.match(/«data HTML([0-9A-F]*)»/i);
    if (match && match[1]) {
      return Buffer.from(match[1], 'hex').toString('utf8');
    }
  } catch (e) {
    // Silently fail to return null
  }
  return null;
}

/**
 * Reads the plain text flavor from the macOS clipboard.
 */
function readTextFromClipboard() {
  return execSync('pbpaste', { encoding: 'utf8' });
}

/**
 * Sets both the HTML and Plain Text flavors on the macOS clipboard.
 */
function setClipboard(html, markdown) {
  const mdTmp = path.join(os.tmpdir(), `mp_md_${Date.now()}.txt`);
  writeFileSync(mdTmp, markdown);

  const htmlHex = Buffer.from(html, 'utf8').toString('hex');
  const appleScript = `
    set theText to (read (POSIX file "${mdTmp}") as «class utf8»)
    set the clipboard to {«class HTML»:«data HTML${htmlHex}», text:theText}
  `;

  const result = spawnSync('osascript', [], { input: appleScript, encoding: 'utf8' });
  unlinkSync(mdTmp);

  if (result.status !== 0) {
    throw new Error(`osascript failed: ${result.stderr}`);
  }
}

async function main() {
  try {
    const rawHtml = readHtmlFromClipboard();
    const hasHtmlFlavor = !!rawHtml;
    const input = rawHtml || readTextFromClipboard();

    if (!input || input.trim() === '') {
      console.error('No content found in clipboard.');
      process.exit(1);
    }

    console.log(`Reading from clipboard... (${input.length} chars)`);
    console.log(`   Preview: ${textToPreview(input)}`);

    const isMarkdown = isProbablyMarkdown(input, hasHtmlFlavor);

    let cleanedHtml;
    let markdown;

    if (isMarkdown) {
      console.log('✨ Markdown detected. Rendering to HTML...');
      markdown = input;
      cleanedHtml = await marked.parse(input);
    } else {
      cleanedHtml = await cleanHTML(input);
      markdown = await convert(input, { clean: true, isMarkdown: false });
    }

    console.log('Updating clipboard...');
    setClipboard(cleanedHtml, markdown);

    // // Verification Step
    // const verifiedHtml = readHtmlFromClipboard();
    // if (verifiedHtml === cleanedHtml) {
    //   console.log('✅ Clipboard verified: HTML flavor matches perfectly.');
    // } else {
    //   console.warn('⚠️  Clipboard verification mismatch!');
    //   if (!verifiedHtml) {
    //     console.warn('   Reason: No HTML flavor found after setting.');
    //   } else {
    //     console.warn(`   Reason: Length difference (${cleanedHtml.length} vs ${verifiedHtml.length})`);
    //   }
    // }

    console.log('\n✅ Clipboard updated with:');
    console.log(`   - Plain Text (Markdown): ${textToPreview(markdown)}`);
    console.log(`   - HTML (Cleaned): ${textToPreview(cleanedHtml)}`);

  } catch (err) {
    console.error('Error during conversion:', err);
    process.exit(1);
  }
}

main();
